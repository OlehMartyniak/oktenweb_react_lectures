Встановити: axios, react-redux, react-hook-form, @reduxjs/toolkit;
1. Папки: components(Car,Cars,CarForm), constants (urls > baseURL, /cars), redux (slices, store > rootReducer, setupStore),
services (axiosService, carService:
                    const carService = {
                        getAll: ()=> axiosService.get(urls.cars),
                        updateById: (id,data) => axiosService.put(`${urls.cars}/${id}`, data),
                        deleteById: (id) => axiosService.delete(`${urls.cars}/${id}`)
                    });

2. Обгорнути головний index в <Provider> і додати store;

3. Створимо carSlice:

                    const initialState = {
                        cars: []
                    }

                    const carSlice = createSlice({
                        name: 'carSlice',
                        initialState,
                        reducers: {}
                    });

                    const {reducer: carReducer} = carSlice;
                    const {carActions} = {};

                    export {carReducer,carActions};

І підключимо carReducer в наш store:

                    const rootReducer = combineReducers({
                        cars: carReducer
                    });

4.В <Cars/> використаємо useSelector, отримаємо доступ до carReducer (одразу деструктуризувавши cars), промапаємо і
виведемо в <Car/>:

                    const {cars} = useSelector(state => state.cars);

                    <div>
                          {cars.map(car => <Car key={car.id} car={car}/>)}
                    </div>

5. Тепер за допомогою функції createAsyncThunk треба побудувати асинхронний запит. Простий варіант виглядав би так:

                    const getAll = createAsyncThunk(
                        'carSlice/getAll',
                        async ()=> {
                            const {data} = await carService.getAll();
                            return data
                        }
                    )

                    const {carActions} = {getAll};

Однак, у нас є можливість помилок від сервера, тому треба прописати алгоритм у випадку помилок з допомогою try/catch
для запису помилки в createAsyncThunk і логіки прописаної в extraReducer власне в carSlice:

                    const initialState = {
                        cars: [],
                        errors: null
                    }

                    const getAll = createAsyncThunk(
                        'carSlice/getAll',
                        async (_,{rejectWithValue})=> {
                            try {
                                const {data} = await carService.getAll();
                                return data
                            } catch (e) {
                                return rejectWithValue(e.response.data)
                            }

                        }
                    )

                    const carSlice = createSlice({
                        name: 'carSlice',
                        initialState,
                        reducers: {},
                        extraReducers:(builder)=>
                            builder
                                .addCase(getAll.fulfilled,(state, action) => {
                                    state.errors = null
                                    state.cars = action.payload
                                })
                                .addCase(getAll.rejected,(state, action) => {
                                    state.errors = action.payload
                                })
                    });

А також в <Cars/> викликаємо useDispatch та useEffect для можливості зміни наших <Car/>:

                        const dispatch = useDispatch();

                        useEffect(()=>{
                            dispatch(carActions.getAll())
                        },[]);

5. Створимо форму для редагування наших <Car/> в <CarForm/>:

                        const CarForm = () => {

                            const {reset,register,handleSubmit,setValue} = useForm();

                            const submit = () => {

                            };

                            return (
                                <form>
                                    <input type="text" placeholder={'model'} {...register('model')}/>
                                    <input type="text" placeholder={'price'} {...register('price')}/>
                                    <input type="text" placeholder={'year'} {...register('year')}/>
                                    <button>update</button>
                                </form>
                            );
                        };

В carSlice в initialState додамо: carForUpdate:null і в reducers:

                        reducers: {
                                setCarForUpdate:(state, action) => {
                                    state.carForUpdate = action.payload
                                }
                            }

Додамо нові значення на експорт:

                        const {reducer: carReducer,actions:{setCarForUpdate}} = carSlice;
                        const carActions = {getAll,setCarForUpdate};

Додамо в <Car/> кнопку і діспатч для зміни:

                        const dispatch = useDispatch();

                         <button onClick={()=>dispatch(carActions.setCarForUpdate(car))}>update car</button>

В   <CarForm/>:

                        const {carForUpdate} = useSelector(state => state.cars);

                        useEffect(()=>{
                            if (carForUpdate) {
                                setValue('model',carForUpdate.model)
                                setValue('price',carForUpdate.price)
                                setValue('year',carForUpdate.year)
                            }
                        },[carForUpdate])

Зробимо createAsyncThunk для  кнопки updade:

                        const updateById = createAsyncThunk(
                            'carSlice/updateById',
                            async ({id,car}) => {
                                const {data} = await carService.updateById(id, car)
                                return data
                            }
                        )

В extraReducers додамо кейс:

                          .addCase(updateById.fulfilled, (state, action) => {
                                          const currentCar = state.cars.find(value => value.id === action.payload.id);
                                          Object.assign(currentCar, action.payload);
                                          state.carForUpdate = null;
                                      })

                          const carActions = {getAll, setCarForUpdate, updateById};

В    <CarForm/>:

                          const dispatch = useDispatch();

                          const submit = async (data) => {
                                  await dispatch(carActions.updateById({id: carForUpdate.id, car: data}))
                                  reset()
                              };









